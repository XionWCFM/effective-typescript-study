

# 1 장 : 타입스크립트 알아보기

## 아이템 1 타입스크립트와 자바스크립트의 관계

- **타입스크립트는 자바스크립트의 상위 집합이다.**
    - → **모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램**이라고 할 수 있다.
    - ← 하지만 반대로 타입스크립트는 별도의 문법을 가지고 있기 때문에 **일반적으로 유효한 자바스크립트 프로그램이 아니라고 할 수 있다.**
- **타입스크립트는 런타임 오류를 발생시키는 코드를 찾아내려고 한다.**
    - 하지만 타입 체커를 통과하면서도 **런타임 오류를 발생시키는 코드가 존재할 수 있기 때문에 모든 오류를 찾아낼것을 기대하면 안된다.**

> 타입스크립트 > 자바스크립트 라고 할 수 있지만 자바스크립트 > 타입스크립트는 X
>

## 아이템 2 타입스크립트 설정

- 타입스크립트의 설정 파일을 사용해야지 타입크릡트를 어떻게 사용할 계획인지 동료들이나 다른 도구들이 알 수 있다. → 설정파일은 tsc —init 으로 간단히 생성된다.
- **noImplicitAny** 는 변수들이 **미리 정의된 타입을 가져야 하는지에 대한 여부를 제어하는 설정옵션**이다.
    - → any 타입을 사용하면 타입스크립트의 장점을 버리는것과 마찬가지이다.
- **strictNullChecks** 는 null 과 undefined 가 모든 타입에서 허용되는지 확인하기 위한 설정이다.

    ```tsx
    const x: number | null = null; // 오류 X
    const x: number = null // 오류
    ```

    - → null / undefined 형식을 할당할 수 없도록 한다.
    - → 하지만 명시적으로 드러냄으로써 오류를 고칠 수 있다.
    - 가급적 사용하면 좋지만 코드를 마이그레이션한다거나 처음 진행하는 프로젝트라면 설정하지 않아도 괜찮다. / **엄격한 체크를 하기 때문에 개발이 힘들수도 있다.**
- 설정상 strict 설정을 하면 대부분의 오류를 잡아낸다.

> strict 설정 → noImplicitAny 와 strictNullChecks 를 포함한 오류 제어 설정
>

## 아이템 3 코드 생성과 타입이 관계없음을 이해하기

- 타입스크립트 컴파일러는 구버전의 자바스크립트로 트랜스파일 하고 코드의 타입 오류를 체크한다.
    - **하지만 이 두가지가 서로 완벽하게 독립적으로 실행된다.**
        - 타입 오류가 있는 코드도 컴파일이 가능하다.
        - 오류가 있을 때 컴파일 하지 않으려면 **noEmitOnError** 옵션을 설정한다.
    - **런타임시에는 타입체크가 불가능하다.**
        - 자바스크립트로 컴파일되는 과정에서 모든 인터페이스 타입 타입구문은 제거된다.

        ```tsx
        type Shape = Square | Rectangle;
        ```

        - 런타임상에 타입 정보를 유지하는 방법은 **런타임에 접근 가능한 타입 정보를 명시적으로 저장하는 태그 기법**이 있다.
        - 혹은 클래스로 생성하면 타입과 값을 모두 사용할 수 있기 때문에 오류가 발생하지 않는다.
    - **타입 연산은 런타임에 영향을 주지 않는다.**
        - as XXX 는 타입 연산 (타입 단언문) 이기 때문에 런타임 동작에는 아무런 영향을 미치지 않는다.
        - 런타임의 타입을 체크해야하고 **자바스크립트 연산을 통해 변환을 수행해야 한다**.
    - **런타임 타입은 선언된 타입과 다를 수 있다.**
        - 타입스크립트에서는 런타임 타입과 선언된 타입이 다를 수 있기 때문에 선언된 타입이 언제든지 달라질 수 있다는 것을 명심해야한다.
    - **타입스크립트 타입으로는 함수를 오버로드 할 수 없다.**
        - 타입과 런타임의 동작이 무관하기 때문에 함수 오버로딩이 불가능하다.
            - 타입수준에서만 동작한다.

            ```tsx
            function add(a: number, b: number): number;
            function add(a: number, b: number): string;
            ```

            - 여러개의 선언문을 작성할 수는 있지만 구현체는 하나이다.
        - **이러한 선언문들은 자바스크립트로 변환되면서 제거되며 구현체만 남게된다.**
    - **타입스크립트 타입은 런타임 성능에 영향을 주지 않는다.**
        - 타입스크립트의 정적 타입은 비용이 전혀 들지 않는다.

> 기본적으로 타입스크립트는 런타임의 성능에 영향을 주지 않으며 컴파일과 타입체크가 독립적으로 실행된다.
>

## 아이템 4 구조적 타이핑에 익숙해지기

- 자바스크립트는 본직적으로 덕 타이핑 기반이다. → 객체가 **어떤 타입**에 부합하는 변수와 메서드를 가질 경우 **객체를 해당 타입에 속하는 것으로 간주하는 방식**
    - 어떠한 두 객체의 관게를 선언하지 않더라도 **일부 속성이 일치한다면** 별다른 구현 필요 없이 로직을 작성 가능하다.
    - 타입스크립트의 타입 시스템에서는 정확한 타입을 표현할 수 없기때문에 구조적 타이핑 관점 (구조가 호환될 때 해당 구조를 사용하는 메서드의 매개변수로 사용이 가능) 에서 오류가 발생하지 않아 **예상과 다른 결과를 리턴하는 함수를 실행할 수 있다.**
    - 이러한 구조적 타이핑으로 인해 라이브러리간의 의존성을 완벽히 분리할 수 있다.

> 타입스크립트는 덕 타이핑을 모델링하기 위해 구조적 타이핑을 사용한다.
>

## 아이템 5 any 타입 지양하기

- 타입스크립트는 타입을 조금씩 추가할 수 있기 때문에 **점진적**이며 동시에 언제든 타입체커를 해제할 수 있기 때문에 **선택적**이다.
    - 일부 특별한 경우를 제외하고는 any를 사용하면 타입스크립트의 장점을 누릴 수 없다.
- **any 타입은 타입 안정성을 갖지 않는다.**
    - 그냥 자바스크립트를 사용하는것과 다를게 없다.
- **any 타입은 함수 시그니처를 무시해버린다.**
    - 함수를 작성할 때는 약속된 타입의 입력을 제공하며 동시에 약속된 타입의 출력을 반환해야한다.
    - 하지만 any 를 사용하면 순수함수 구현 X
- any 타입은 언어 서비스가 적용되지 않는다.
    - 타입스크립트는 **심볼에 타입이 존재할 때만 자동완성 기능과 도움말을 제공한다.**
    - 우리가 흔히 사용하는 코드 에디터의 이름 변경 같은 기능 또한 사용할 수 없다.
- any 타입은 리팩토링 시 버그를 감춘다.
- any 타입은 타입 설계를 감춰버린다.
    - 상태 객체의 설계를 감춰버리기 때문에 유지보수가 어려워진다.
- any 타입은 타입 시스템의 신뢰도를 떨어트린다.

> 왠만하면 any 를 사용하지 말고 정확한 타입을 모델링 및 설계하여 적용하자.
>