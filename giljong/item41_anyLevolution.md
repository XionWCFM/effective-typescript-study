# any의 진화

일반적으로 타입스크립트의 타입은 변수를 선언할 때 결정됩니다.

그 이후 타입가드 등의 처리를 통해 타입이 정제될 수는 있지만

새로운 값이 추가되도록 확장하는 것은 불가능합니다.

<br/>

그러나 `any` 타입의 경우에는 예외적으로 이러한 확장이 허용되는 경우가 있습니다.

```tsx

function range(start:number,limit:number) {
    const out = []
    for (let i = start ; i < limit ; i++) {
        out.push(i)
    }
    return out // 반환 타입은 number[]
} 

```

const out = []

시점에서 out의 타입은 any[] 입니다.

그러나 out.push(i)를 통해 number 타입의 값을 out 변수에 넣는 시점에서

out 변수의 타입은 number[]로 진화하게 됩니다.

이러한 진화는 타입 좁히기와는 다른 개념이라고 볼 수 있습니다.


<br/>

타입 좁히기는 점점 타입이 좁아지는 것을 의미하지만

이러한 any 의 진화는 타입의 확장이 허용 되기 때문입니다.

```tsx

const result = [] // type any[]
result.push('a')
result // type string[]
result.push(1)
result // type (string|number)[]

```

원래는 any[] 였던 타입이 마지막에는 유니온을 가지는 배열이 되었습니다.

# 타입의 진화의 조건

이러한 타입의 진화는 noImplicitAny가 설정된 상태에서

변수의 타입이 암시적 any | any[] 인 경우에만 발생합니다.

즉 명시적으로 any 타입을 선언하면 타입은 그대로 유지됩니다.

# 그러나...

any를 진화시켜서 써먹는것보다는

그냥 명시적으로 타입 구문을 지정해주는 게 더 안전합니다.

그냥 이런게...있다.. 정도로만 알고 가시면

나중에 당황할 일이 줄긴 할 것 같네요

이펙티브 타입스크립트에서도 이런게 있으니 이해할 수 있으면 되었다와 같은 뉘앙스로 적혀있다고 저는 느꼈습니다.

# 마치며

실제로 실습해본 결과 noImplicitAny가 설정되어 있지 않으면

타입의 진화는 이루어지지 않습니다.

그런데 저는 저 옵션을 일반적으로 끄고 사용해서 더더욱 타입의 진화에 무지할 수 밖에 없었네요

저 옵션 끄고 쓸거면 그냥 신경 안쓰셔도 될 듯합니다.