# 왜 객체 래퍼 타입을 피해야할까?

자바스크립트에는 객체 이외에도 기본형 값들에 대한 일곱가지 타입이 있습니다.

(string, number, boolean, null, undefined , symbol, bigint) 가 있지요!

이런 기본형들은 기본적으로 imutable 하며 메서드를 가지지 않는다는 점에서 객체와 구분됩니다.

<br/>

그런데 쉽게 착각할 수 있는 부분은 string 타입에는 

마치 메서드를 가지고 있는 것처럼 사용할 수 있다는 것입니다.

```tsx
'primitive'.charAt(3)
```

이러한 문법이 가능한 이유는 자바스크립트가 원시타입에 대한 프로토타입을 적용할 때에

wrapper 객체를 생성하고 버리는 형태로 구현하기 때문입니다.

조금 난해하게 느껴질 수 있지만 자바스크립트에서 문자열을 생성하는 방식은 여러가지가 있습니다.


```tsx
const hi = new String('안녕하세요')
const hi = '안녕하세요'
```

두가지 방법으로 생성가능합니다.

문자열은 String.Prototype을 프로토타입으로 갖습니다.

그러나 `new String` 으로 생성한 hi의 타입은 'object' 이며

문자열 리터럴을 사용하여 '안녕하세요' 로 생성한 hi의 타입은 'string'입니다.

<br/>

생성자 함수를 통해 new String으로 생성한 object의 경우에는

프로토타입이 연결되어있는 것을 직관적으로 이해할 수 있지만

'안녕하세요'로 생성한 문자열의 경우에는 타입이 원시 타입 string 이기 때문에

'안녕하세요'.charAt과 같은 문자열 메서드를 사용하려고 하는 경우나

점표기법을 통하여 마치 객체처럼 접근하게 되는 경우

자바스크립트는

<br/>

1. 래퍼객체를 임시로 생성

2. 문자열을 래퍼객체로 래핑

3. 래퍼객체를 통하여 String 프로토타입에 접근

4. String 프로토타입이 가지고 있는 메서드를 사용

5. 메서드 호출이 끝난 뒤 래퍼 객체를 삭제

하는 순서대로 동작하게 됩니다.

<br/>

**문제점은 타입스크립트가 기본형과 객체 래퍼 타입을 별도로 모델링 한다는 것입니다.**

string은 원시타입 string 이지만

객체 래퍼 타입인 String은 String.prototype을 가지고 있는 오브젝트입니다.

따라서 이 둘은 전혀 별개의 타입이 되는 것임에도 불구하고

string 타입이냐 String 타입이냐의 차이밖에 없기 때문에 혼동하기 쉽습니다.