# typeWidening

타입스크립트가 작성된 코드를 정적 분석하는 시점에서

변수는 '가능한' 값들의 집합인 타입을 가지게됩니다.

상수를 사용해서 변수를 초기화 할 때에 타입을 명시하지 않으면 타입 체커는

타입을 결정해야하고 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야합니다.


<br/>

타입스크립트는 이러한 과정을 타입 넓히기(widening)이라고 부릅니다.

타입 넓히기는 직관적으로 이해하기 어려울 수 있습니다.

이것은 타입스크립트가 **정확한 유형을 결정할 수 없을 때 변수에 대하여 보다 일반적인 유형을 유추**하는 것입니다.

이는 타입추론 상황에서 주로 발생하는 현상입니다.

```tsx
interface Vector3 {
    x:number;
    y:number;
    z:number;

}

function getComponent(vector:Vector3, axis:'x'|'y'|'z'){
    return vector[axis]
}

let x = 'x'
let vec = {x:10, y:20 , z:30}

getComponent(vec,x) // error 변수 x는 string입니다.
```

이 코드는 변수 x가 'x'|'y'|'z' 타입에 호환 될 것을 기대했으나

타입스크립트의 타입추론 시스템은 보다 넓은 타입으로 타입을 확장하였기 때문에

변수 x는 리터럴 타입 x 대신 string 타입으로 취급되어 에러가 발생합니다.

이를 해결해주기 위해서는 x의 타입을 직접 명시해주어야합니다.

<br/>

# 타입 넓히기를 방지하는 방법

타입 넓히기는 타입스크립트의 타입 추론 시스템을 구성하는 중요한 기능 중 하나입니다.

그러나 타입 넓히기로 인하여 개발자가 예상치 못한 동작이 발생하기도 하기 때문에

타입 넓히기를 방지하는 방법 역시 알아두면 좋습니다.

## const

const를 이용하여 변수를 선언하는 것을 통해 좁은 타입으로 만들어 줄 수 있습니다.

예컨대 위의 예제의 경우 

```tsx
const x = 'x'
```

로 선언 방식을 바꿔주면 타입스크립트는 의심의 여지 없이 더 좁은 타입으로

타입을 추론합니다.


하지만 이러한 방법은 리터럴 타입에서만 의도대로 동작하고

오브젝트, 배열에는 사용할 수 없다는 문제가 있습니다.

## 명시적 타입 구문 제공하기

타입 구문을 명시적으로 제공하는 것을 통해

타입스크립트는 타입추론 대신 제공된 타입을 사용합니다.

```tsx
const v:{x:1|3|5} = {
    x:1
}
```


## as const 단언문 사용하기

타입스크립트가 제공하는 as const 문법을 사용해도 좋습니다.

```tsx
let x = 'x' as const
```

const 단언문은 변수 선언에 쓰이는 let, const와는 다릅니다.

값 뒤에 as const를 작성하면 타입스크립트는 최대한 좁은 타입으로 타입 추론을 수행합니다.

# 마치며

타입 넓히기는 타입 추론을 적극적으로 사용하는 타입스크립트에서 매우 중요한 개념 중 하나입니다.

솔직히 말하면 제가 지금까지 타입스크립트에서 만난 오류 중 일부분은

타입 넓히기를 제대로 알고 있지 못해서 발생한 것도 있어보이네요..


